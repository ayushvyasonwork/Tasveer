import Post from "../models/Post.js";
import User from "../models/User.js";
import { getImageUrl } from "../utils/getImageUrl.js";
import { cloudinary } from "../config/cloudinary.js";
import fs from "fs";
import path from "path";
import streamifier from "streamifier";
import { json } from "stream/consumers";

const detectAIGeneratedImage = async (base64ImageData, mimeType) => {
  const apiKey = process.env.GEMINI_API_KEY;
  if (!apiKey) {
    console.warn("âš ï¸ GEMINI_API_KEY is not set. Skipping AI detection.");
    return false;
  }

  // ðŸ§  Stronger, deterministic prompt
  const prompt = `
You are an expert digital image analyst.

Your ONLY task:
Determine if this image was generated by AI.

Consider:
- Unnatural skin textures or smoothness
- Anatomical issues (hands, fingers, eyes)
- Lighting or reflection inconsistencies
- Unrealistic backgrounds or blending
- Absence of natural photographic noise
- Repetitive or illogical patterns

You must reply ONLY with a single JSON object like:
{"isAIGenerated": true} or {"isAIGenerated": false}

Do NOT include explanations or text before/after the JSON.
`;

  const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`;

  const payload = {
    contents: [
      {
        parts: [
          { text: prompt },
          { inline_data: { mime_type: mimeType, data: base64ImageData } },
        ],
      },
    ],
    generationConfig: { temperature: 0.1, topP: 0.1 }, // more deterministic
  };

  try {
    const response = await fetch(apiUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
    });

    if (!response.ok) {
      console.error("âŒ Gemini API Error:", response.status, await response.text());
      return false;
    }

    const result = await response.json();
    console.log("ðŸ“© Gemini API full response:", JSON.stringify(result, null, 2));

    // ðŸ§© Safely extract and clean response text
    let rawText =
      result.candidates?.[0]?.content?.parts
        ?.map((p) => p.text || "")
        .join(" ")
        .trim() || "";

    // Gemini sometimes wraps JSON in ```json ... ```
    const cleaned = rawText.replace(/```json|```/g, "").trim();

    let jsonResult;
    try {
      jsonResult = JSON.parse(cleaned);
    } catch (parseErr) {
      console.error("âš ï¸ JSON parsing failed. Raw text was:", rawText);
      return false;
    }

    console.log("âœ… Gemini AI Detection Parsed Result:", jsonResult);
    return jsonResult.isAIGenerated ?? false;
  } catch (error) {
    console.error("ðŸš¨ Failed to call Gemini API:", error);
    return false;
  }
};


export const createPost = async (req, res) => {
  try {
    const { userId, description } = req.body;
    const user = await User.findById(userId);
    if (!user) {
      return res.status(404).json({ message: "User not found" });
    }
    let isImageAIGenerated = false; 
    let pictureUrl = null;
    let picturePublicId = null; 
    console.log('req.file.mimetype',req.file.mimetype);
    if (req.file && req.file.buffer) {
      console.log("âœ… File received. Starting AI analysis...");
      const base64Image = req.file.buffer.toString('base64');
isImageAIGenerated = await detectAIGeneratedImage(base64Image, req.file.mimetype);
      console.log("AI Detection Result:", isImageAIGenerated);      
      const uploadPromise = new Promise((resolve, reject) => {
        const uploadStream = cloudinary.uploader.upload_stream(
          { folder: "posts" }, 
          (error, result) => {
            if (error) {
              reject(error);
            } else {
              resolve(result);
            }
          }
        );
        streamifier.createReadStream(req.file.buffer).pipe(uploadStream);
      });
      
      const cloudinaryResult = await uploadPromise;
      pictureUrl = cloudinaryResult.secure_url;
      picturePublicId = cloudinaryResult.public_id;
      console.log("âœ… Image uploaded to Cloudinary:", pictureUrl);
    } else {
      console.log("No file uploaded, skipping AI analysis and Cloudinary upload.");
    }
    // 5. Create the new post with the correct data
    const newPost = new Post({
      userId,
      firstName: user.firstName,
      lastName: user.lastName,
      location: user.location,
      description,
      userPicturePath: await getImageUrl(req, user.picturePath), // This should probably be user.picturePath
      picturePath: pictureUrl,
      picturePublicId: picturePublicId, // IMPORTANT: Save this for deletion
      likes: {},
      comments: [],
      isAIGenerated: isImageAIGenerated,
    });

    await newPost.save();

    // Invalidate cache and return all posts
    await req.redisClient.del("posts"); 
    const posts = await Post.find().sort({ createdAt: -1 });
    res.status(201).json(posts);

  } catch (err) {
    console.error("Error in createPost:", err);
    res.status(409).json({ message: err.message });
  }
};
export const deletePost = async (req, res) => {
  try {
    const { id } = req.params;

    const post = await Post.findById(id);
    if (!post) {
      return res.status(404).json({ success: false, message: "Post not found" });
    }

    // 1ï¸âƒ£ Delete from MongoDB
    await Post.findByIdAndDelete(id);

    // 2ï¸âƒ£ Delete from Cloudinary if exists
    if (post.picturePublicId) {
      try {
        await cloudinary.uploader.destroy(post.picturePublicId);
        console.log("âœ… Cloudinary image deleted:", post.picturePublicId);
      } catch (err) {
        console.error("âŒ Cloudinary delete failed:", err.message);
      }
    }

    // 3ï¸âƒ£ Delete from local multer storage
    if (post.picturePath && post.picturePath.includes("/assets/")) {
      const localFilename = post.picturePath.split("/assets/")[1];
      const localPath = path.join("public/assets", localFilename);
      fs.unlink(localPath, (err) => {
        if (err) console.error("âš ï¸ Local file delete failed:", err.message);
        else console.log("âœ… Local file deleted:", localPath);
      });
    }

    // 4ï¸âƒ£ Invalidate Redis cache
    try {
      await req.redisClient.del("posts");
      await req.redisClient.del("stories");
      if (post.picturePath) {
        await req.redisClient.del(`image:${post.picturePath}`);
      }
      console.log("âœ… Redis cache invalidated for deleted post:", id);
    } catch (redisErr) {
      console.error("Redis cache clear failed:", redisErr.message);
    }

    res.send({
      success: true,
      message: "Post deleted everywhere (DB, Redis, Cloudinary, Local)",
    });
  } catch (err) {
    res.status(500).json({ message: err.message });
  }
};

/* -------------------- GET FEED POSTS -------------------- */
export const getFeedPosts = async (req, res) => {
  try {
    // 1ï¸âƒ£ Check Redis cache
    const cached = await req.redisClient.get("posts");
    if (cached) {
      return res.status(200).json(JSON.parse(cached));
    }

    // 2ï¸âƒ£ Fallback: DB query
    const posts = await Post.find().sort({ createdAt: -1 });

    // 3ï¸âƒ£ Save to Redis (cache for 1 min or so)
    await req.redisClient.setEx("posts", 60, JSON.stringify(posts));

    res.status(200).json(posts);
  } catch (err) {
    res.status(404).json({ message: err.message });
  }
};


/* -------------------- GET USER POSTS -------------------- */
export const getUserPosts = async (req, res) => {
  try {
    const { userId } = req.params;
    const posts = await Post.find({ userId }).sort({ createdAt: -1 });
    res.status(200).json(posts);
  } catch (err) {
    res.status(404).json({ message: err.message });
  }
};

/* -------------------- LIKE / UNLIKE POST -------------------- */
export const likePost = async (req, res) => {
  try {
    const { id } = req.params;
    const { userId } = req.body;
    const post = await Post.findById(id);

    const isLiked = post.likes.get(userId);
    if (isLiked) {
      post.likes.delete(userId);
    } else {
      post.likes.set(userId, true);
    }

    const updatedPost = await Post.findByIdAndUpdate(
      id,
      { likes: post.likes },
      { new: true }
    );

    res.status(200).json(updatedPost);
  } catch (err) {
    res.status(404).json({ message: err.message });
  }
};

/* -------------------- ADD COMMENT -------------------- */
export const addComment = async (req, res) => {
  try {
    const { id: postId } = req.params;
    const { userId, text } = req.body;

    if (!text?.trim()) {
      return res.status(400).json({ message: "Comment text is required." });
    }

    const post = await Post.findById(postId);
    if (!post) return res.status(404).json({ message: "Post not found." });

    post.comments.push({ userId, text });
    await post.save();

    const updatedPost = await Post.findById(postId).populate({
      path: "comments.userId",
      select: "firstName lastName picturePath",
    });

    res.status(200).json(updatedPost);
  } catch (err) {
    console.error("Error adding comment:", err);
    res.status(500).json({ message: "Failed to add comment." });
  }
};

/* -------------------- GET COMMENTS -------------------- */
export const getComments = async (req, res) => {
  try {
    const { id: postId } = req.params;

    const post = await Post.findById(postId).populate({
      path: "comments.userId",
      select: "firstName lastName picturePath",
    });

    if (!post) return res.status(404).json({ message: "Post not found." });

    res.status(200).json(post.comments);
  } catch (err) {
    console.error("Error getting comments:", err);
    res.status(500).json({ message: "Failed to fetch comments." });
  }
};
